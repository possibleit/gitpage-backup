I"Ä0<h1 id="hashmapæºç åˆ†æ2">HashMapæºç åˆ†æï¼ˆ2ï¼‰</h1>
<hr />

<p>è¿™å‡ å¤©å› ä¸ºç–«æƒ…é—®é¢˜ï¼Œä¸€ç›´å¾…åœ¨å®¶é‡Œï¼Œå‰å‡ å¤©è¿˜å¾—äº†æµæ„Ÿï¼Œå’³å—½å’½ç—›ï¼Œæå¿ƒåŠèƒ†çš„ã€‚æ˜¨å¤©ç»ˆäºå¥½è½¬ï¼Œä¹Ÿæ¥åˆ°é€šçŸ¥å»¶è¿Ÿå¼€å­¦ã€‚æƒ³ç€åœ¨å®¶ä¹Ÿè¦ä¿æŒå¥½çŠ¶æ€ï¼Œå¥½å¥½å­¦ä¹ ï¼Œå°±æƒ³ç»™è‡ªå·±æ‰¾ç‚¹äº‹å¹²ã€‚åˆšå¥½ä¹‹å‰çš„ä¸€ç¯‡åšå®¢å¯¹hashmapåˆ†æçš„ä¸æ˜¯å¾ˆé€å½»ï¼Œåˆšå¥½è¶ç°åœ¨çš„æ—¶é—´ï¼Œå¥½å¥½å†™å†™åšå®¢ï¼ŒåŒæ—¶ä¹Ÿæé«˜ä¸€ä¸‹è‡ªå·±ã€‚å­¦ç–æ‰æµ…ï¼Œæœ‰ä¸å½“ä¹‹å¤„ï¼Œæœ›æŒ‡å‡ºã€‚</p>

<hr />

<p>java version ï¼šjdk 1.8</p>

<hr />

<h3 id="1-æ„é€ æ–¹æ³•">1. æ„é€ æ–¹æ³•</h3>

<p>æƒ¯ä¾‹ï¼Œå…ˆçœ‹æºç </p>
<pre><code class="language-java">    public HashMap(int initialCapacity, float loadFactor) {
        if (initialCapacity &lt; 0)
            throw new IllegalArgumentException("Illegal initial capacity: " +
                                               initialCapacity);
        if (initialCapacity &gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException("Illegal load factor: " +
                                               loadFactor);
        this.loadFactor = loadFactor;
        this.threshold = tableSizeFor(initialCapacity);
    }

    public HashMap(int initialCapacity) {
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    }

    public HashMap() {
        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
    }

    public HashMap(Map&lt;? extends K, ? extends V&gt; m) {
        this.loadFactor = DEFAULT_LOAD_FACTOR;
        putMapEntries(m, false);
    }
</code></pre>
<p>åœ¨åˆ†æè¿™å››ä¸ªæ„é€ æ–¹æ³•ä¹‹å‰ï¼Œè¿˜éœ€è¦äº†è§£hashmapä¸­çš„å‡ ä¸ªå±æ€§ï¼Œ</p>
<ul>
  <li>loadFactor : è£…è½½å› å­</li>
  <li>threshold  : æ‰©å®¹é˜ˆå€¼ï¼Œä¹Ÿå°±æ˜¯è¯´å½“hashmapä¸­çš„æ•°æ®ä¸ªæ•°è¶…è¿‡è¿™ä¸ªé˜ˆå€¼ï¼Œå°±æ‰©å®¹</li>
</ul>

<p>hashmapå‰ä¸‰ä¸ªæ„é€ æ–¹æ³•éƒ½æ˜¯åˆå§‹åŒ–å‚æ•°ï¼Œåœ¨è¿™äº›æ„é€ æ–¹æ³•ä¸­å¹¶æ²¡æœ‰åˆå§‹åŒ–èŠ‚ç‚¹æ•°ç»„ï¼ŒäºŒååˆå§‹åŒ–äº†è£…è½½å› å­å’Œæ‰©å®¹é˜ˆå€¼è¿™ä¸¤ä¸ªå‚æ•°ï¼Œåœ¨<code>put</code>æ–¹æ³•ä¸­æ ¹æ®æ‰©å®¹é˜ˆå€¼æ¥åˆå§‹åŒ–æ•°ç»„ã€‚</p>
<pre><code class="language-python">if ((tab = table) == null || (n = tab.length) == 0)
    n = (tab = resize()).length;
</code></pre>
<p>ç”±æ­¤å¯ä»¥çœ‹å‡ºåˆå§‹åŒ–æ•°ç»„ä½¿ç”¨çš„æ˜¯<code>resize()</code>æ–¹æ³•ã€‚</p>
<pre><code class="language-java">    final Node&lt;K,V&gt;[] resize() {
        // è¿™æ®µä»£ç ä¸­å…³äºæ‰©å®¹çš„åˆ†æ”¯è¢«æˆ‘åˆ é™¤äº†ï¼Œç•™ä¸‹çš„éƒ½æ˜¯åˆå§‹åŒ–æ•°ç»„çš„åˆ†æ”¯ 
        Node&lt;K,V&gt;[] oldTab = table;
        int oldCap = (oldTab == null) ? 0 : oldTab.length;// æ—§å®¹é‡ï¼Œåˆå§‹åŒ–æ•°ç»„æ—¶ä¸º0
        int oldThr = threshold;
        int newCap, newThr = 0;
        if (oldThr &gt; 0) // æ˜¯å¦æŒ‡å®šäº†æ•°ç»„å¤§å°
            newCap = oldThr;
        else { //ä½¿ç”¨é»˜è®¤å‚æ•°
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }
        if (newThr == 0) { // åˆ¤æ–­æ•°ç»„å¤§å°æ˜¯å¦è¶Šç•Œ
            float ft = (float)newCap * loadFactor;
            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        }
        threshold = newThr;
        @SuppressWarnings({"rawtypes","unchecked"})
        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
        table = newTab;
        return newTab;
    }
</code></pre>
<p>æ„é€ æ–¹æ³•ä¸€ä¸­è¿˜æ˜¯ç”¨äº†å¦ä¸€ä¸ªæ–¹æ³•<code> this.threshold = tableSizeFor(initialCapacity)</code>ï¼Œä¹Ÿå°±æ˜¯è¯´æ—¢æŒ‡å®šäº†åˆå§‹å®¹é‡åˆæŒ‡å®šäº†è£…è½½å› å­æ—¶ï¼Œä½¿ç”¨è¿™ä¸ªæ–¹æ³•ç¡®å®šæ‰©å®¹é˜ˆå€¼ã€‚</p>
<pre><code class="language-java">    static final int tableSizeFor(int cap) {
        // Integer.numberOfLeadingZeros(cap - 1)`æ–¹æ³•è¿”å›32ä½intç±»å‹æ•°é«˜ä½çš„0çš„ä¸ªæ•°ã€‚è¿™é‡Œçš„æºç å·§å¦™åœ°ä½¿ç”¨äº†äºŒåˆ†æ³•ä½¿ç”¨äº†å››æ¬¡å³ç§»æ“ä½œï¼Œæ‰¾å‡ºäº†é«˜ä½0ä¸ªæ•°
        int n = -1 &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - 1);
        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    }
</code></pre>

<p>è¿™ä¸ªæ–¹æ³•çš„ä½œç”¨æ˜¯æ‰¾åˆ°å¤§äºç­‰äº <code>initialCapacity</code> çš„æœ€å°çš„ 2 çš„å¹‚ã€‚å‡è®¾è¾“å…¥çš„å€¼æ˜¯10</p>

<pre><code>cap = 10,cap - 1 = 9,é«˜ä½çš„0æœ‰28ä¸ª
n = -1 &gt;&gt;&gt; 28
æºç  10000000000000000000000000000001
åç  11111111111111111111111111111110
è¡¥ç  11111111111111111111111111111111
å³ç§» 00000000000000000000000000001111
n = 8 + 4 + 2 + 1 = 15
n + 1 = 16
</code></pre>

<p>åˆ†æä»¥ä¸Šæºç æˆ‘ä»¬çŸ¥é“ï¼Œå¦‚æœé»˜è®¤ä¸ä¼ å…¥å‚æ•°ï¼Œé‚£ä¹ˆhashmapåˆå§‹åŒ–ä¸ºå¤§å°ä¸º16ï¼Œè£…è½½å› å­ä¸º0.75çš„æ•°ç»„ã€‚å¦‚æœä¼ å…¥çš„æœ‰åˆå§‹å®¹é‡ï¼Œé‚£ä¹ˆæ•°ç»„å¤§å°ä¼šè¢«åˆå§‹åŒ–ä¸ºå¤§äºç­‰äºç»™å®šå€¼çš„æœ€å°çš„2çš„å¹‚ã€‚ä¹‹æ‰€ä»¥æ˜¯2çš„å¹‚ï¼Œåœ¨ä¹‹åæ±‚hashå€¼æ—¶ä¼šç”¨åˆ°ã€‚</p>

<h3 id="2-putæ–¹æ³•">2. putæ–¹æ³•</h3>
<p>æƒ¯ä¾‹ï¼Œå…ˆçœ‹æºç </p>
<pre><code class="language-java">    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
        if ((tab = table) == null || (n = tab.length) == 0)
            // æ•°ç»„æœªåˆå§‹åŒ–åˆ™è°ƒç”¨resizeåˆå§‹åŒ–
            n = (tab = resize()).length;
        if ((p = tab[i = (n - 1) &amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else {
            Node&lt;K,V&gt; e; K k;
            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                e = p;
            else if (p instanceof TreeNode)
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
            else {
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break;
                    p = e;
                }
            }
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
        if (++size &gt; threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    }
</code></pre>

<p>å…·ä½“çš„ä»£ç æ‰§è¡Œæµç¨‹ä¸Šä¸€ç¯‡åšå®¢é‡Œå·²ç»åˆ†æäº†ï¼Œè¿™é‡Œåªåˆ†æå‡ ç‚¹ã€‚</p>
<ul>
  <li>hashæ–¹æ³•
    <pre><code class="language-java">  static final int hash(Object key) {
      int h;
      return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
  }
</code></pre>
    <p>hashmapçš„<code>hash</code>æ–¹æ³•ä¼šé¦–å…ˆè°ƒç”¨keyçš„<code>hashCode()</code>æ–¹æ³•ï¼Œå¾—åˆ°ä¸€ä¸ªintç±»å‹çš„å€¼ï¼Œç„¶åå°†å…¶å³ç§»16ä½ï¼Œå¹¶äºåŸæ¥çš„å€¼æŒ‰ä½å¼‚æˆ–è¿ç®—ã€‚è¿™ä¹ˆåšçš„åŸå› æ˜¯ï¼Œä¸ºäº†æœ‰æ›´å¥½çš„æ•£åˆ—æ€§åŒæ—¶åˆæœ‰è¾ƒå¥½çš„æ€§èƒ½ã€‚å› ä¸ºè®¡ç®—æ•°ç»„ä¸‹æ ‡æ—¶ï¼ˆ<code>p = tab[i = (n - 1) &amp; hash]</code>ï¼‰æ˜¯ä»…æœ‰hashå€¼çš„ä½ä½å‚ä¸è¿ç®—ï¼Œè€Œè¿™ä¸ªæ–¹æ³•å°†åŸæ¥çš„å€¼é«˜ä½ä¸ä½ä½å¼‚æˆ–ä¹‹åæ”¾åˆ°ä½ä½ï¼Œå°†é«˜ä½ä¹Ÿå‚ä¸åˆ°è¿ç®—ä¸­ï¼Œæ‰€ä»¥å…·æœ‰è¾ƒå¥½çš„æ•£åˆ—æ€§ã€‚åŒæ—¶åªæ˜¯è¿›è¡Œå¼‚æˆ–è¿ç®—ï¼Œä¹Ÿå‡å°äº†ç³»ç»Ÿå¼€é”€ã€‚</p>
  </li>
  <li>æ’å…¥nullé”®å€¼å¯¹<br />
ä»<code>hash</code>æ–¹æ³•ä¸­å¯ä»¥çœ‹åˆ°ï¼Œå½“æ’å…¥çš„keyä¸ºnullæ—¶ï¼Œæ–¹æ³•è¿”å›0ï¼Œè€Œ<code>p = tab[i = (n - 1) &amp; hash]</code>è®¡ç®—ä¸‹è¡¨ä½¿ç”¨äº†ä¸æ–¹æ³•ï¼Œæ‰€ä»¥æœ€ç»ˆå¾—åˆ°çš„ä¸‹æ ‡ä¸º0ï¼Œä¹Ÿå°±æ˜¯è¯´æ’å…¥åˆ°æ•°ç»„çš„ç¬¬ä¸€ä¸ªä½ç½®ã€‚</li>
</ul>

<h3 id="3-æ‰©å®¹æ“ä½œ">3. æ‰©å®¹æ“ä½œ</h3>
<p>æƒ¯ä¾‹ï¼Œå…ˆçœ‹æºç </p>
<pre><code class="language-java">final Node&lt;K,V&gt;[] resize() {
        Node&lt;K,V&gt;[] oldTab = table;
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
        int oldThr = threshold;
        int newCap, newThr = 0;
        if (oldCap &gt; 0) {
            if (oldCap &gt;= MAXIMUM_CAPACITY) {
                threshold = Integer.MAX_VALUE;
                return oldTab;
            }
            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
                // æ‰©å®¹ä¸ºåŸæ¥å¤§å°çš„ä¸¤å€
                newThr = oldThr &lt;&lt; 1; // double threshold
        }
        if (newThr == 0) {
            float ft = (float)newCap * loadFactor;
            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        }
        threshold = newThr;
        @SuppressWarnings({"rawtypes","unchecked"})
        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
        table = newTab;
        if (oldTab != null) {
            for (int j = 0; j &lt; oldCap; ++j) {
                Node&lt;K,V&gt; e;
                if ((e = oldTab[j]) != null) {
                    oldTab[j] = null;
                    if (e.next == null)
                        newTab[e.hash &amp; (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                    else { // preserve order
                        Node&lt;K,V&gt; loHead = null, loTail = null;
                        Node&lt;K,V&gt; hiHead = null, hiTail = null;
                        Node&lt;K,V&gt; next;
                        do {
                            next = e.next;
                            if ((e.hash &amp; oldCap) == 0) {
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            }
                            else {
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            }
                        } while ((e = next) != null);
                        if (loTail != null) {
                            loTail.next = null;
                            newTab[j] = loHead;
                        }
                        if (hiTail != null) {
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        }
                    }
                }
            }
        }
        return newTab;
    }
</code></pre>
<p>å› ä¸ºhashmapæ‰©å®¹ä¹‹åå¤§å°ä¸ºåŸæ¥çš„äºŒå€ï¼Œæ—§æ•°ç»„ä¸­çš„å…ƒç´ åœ¨æ–°æ•°ç»„ä¸­ä¼šé‡æ–°è®¡ç®—ä¸‹æ ‡ã€‚è®¡ç®—çš„æ–¹æ³•æ˜¯æ•°ç»„å®¹é‡çš„å€¼å‡ä¸€åä¸å…ƒç´ keyçš„hashå€¼åšä¸è¿ç®—ã€‚å› æ­¤å¯¹äºæ¯ä¸ªå…ƒç´ ä¼šæœ‰ä¸¤ç§æƒ…å†µã€‚</p>

<ul>
  <li>å‡è®¾æ•°ç»„å®¹é‡ä¸º16
```
cap - 1 = 15 = 1111
key1  00000000000000000000000000011001
cap-1 00000000000000000000000000001111
hash1 00000000000000000000000000001001 = 9</li>
</ul>

<p>key1  00000000000000000000000000001001
cap-1 00000000000000000000000000001111
hash1 00000000000000000000000000001001 = 9</p>
<pre><code>

- æ‰©å®¹ä¹‹åæ•°ç»„å®¹é‡ä¸º32
</code></pre>
<p>cap - 1 = 31 = 11111
key1  00000000000000000000000000011001
cap-1 00000000000000000000000000011111
hash1 00000000000000000000000000011001 = 25</p>

<p>key1  00000000000000000000000000001001
cap-1 00000000000000000000000000011111
hash1 00000000000000000000000000001001 = 9
```
ä¹Ÿå°±æ˜¯è¯´ï¼Œæ‰©å®¹åæ¯ä¸ªå…ƒç´ ï¼Œè¦ä¹ˆåœ¨åŸæ¥çš„ä½ç½®ï¼Œè¦ä¹ˆç§»åŠ¨åˆ°åŸæ¥çš„ä½ç½®åŠ ä¸Šoldcapæ‰€åœ¨çš„ä½ç½®ã€‚</p>
<h3 id="4-hashmapçº¿ç¨‹ä¸å®‰å…¨çš„åŸå› ">4. hashmapçº¿ç¨‹ä¸å®‰å…¨çš„åŸå› </h3>

<ul>
  <li>å› ä¸ºhashmapçš„putæ–¹æ³•ä¸æ˜¯åŒæ­¥çš„ï¼Œå‡å¦‚æœ‰ä¸¤ä¸ªçº¿ç¨‹åŒæ—¶putä¸¤ä¸ªhashå€¼ç›¸åŒçš„æ•°æ®ï¼Œé‚£ä¹ˆä¸ç®¡æ˜¯å¤´æ’æ³•è¿˜æ˜¯å°¾æ’æ³•ï¼Œæœ€ç»ˆä¸€å®šä¼šæœ‰ä¸€ä¸ªæ•°æ®ä¸¢å¤±ã€‚</li>
  <li>jdk1.8ä¹‹å‰ï¼Œhahsmapæ’å…¥å…ƒç´ ä½¿ç”¨å¤´æ’æ³•ï¼Œå¤šçº¿ç¨‹æ“ä½œæ—¶ï¼Œä¼šå‡ºç°å¾ªç¯é“¾è¡¨ï¼Œæ­¤æ—¶getæ•°æ®æ—¶ä¼šé€ æˆæ­»å¾ªç¯ã€‚</li>
</ul>

:ET